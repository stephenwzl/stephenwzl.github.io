<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> objc的 block · stephenwzl</title><meta name="description" content="objc的 block - stephenwzl"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avatar.png"><link rel="stylesheet" href="/css/apollo-v1.css"><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-118080805-1"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-118080805-1');</script><link rel="search" type="application/opensearchdescription+xml" href="https://stephenwzl.github.io/atom.xml" title="stephenwzl"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/wangzhilong110" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/stephenwzl" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">objc的 block</h1><div class="post-info">Jun 11, 2017</div><div class="post-content"><p>在没有认清 Block的真实面目前，日常处理 Block相关的逻辑时可以说是战战兢兢、如履薄冰。在经过一阵迷茫和抓狂后，挖到了 Clang文档对于 Block实现的<a href="https://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="noopener">解释</a>。虽然相对于当前的 Block实现不是100%完整，但也可以管中窥豹了。<br><a id="more"></a></p>
<p>从 ABI层面看，Block由一个特定的内存布局（aka layout）和运行时方法组成，先看一下文档的结构描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_literal_1</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa; <span class="comment">// initialized to &amp;_NSConcreteStackBlock or &amp;_NSConcreteGlobalBlock</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor_1</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;         <span class="comment">// NULL</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;         <span class="comment">// sizeof(struct Block_literal_1)</span></span><br><span class="line">        <span class="comment">// optional helper functions</span></span><br><span class="line">        <span class="keyword">void</span> (*copy_helper)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);     <span class="comment">// IFF (1&lt;&lt;25)</span></span><br><span class="line">        <span class="keyword">void</span> (*dispose_helper)(<span class="keyword">void</span> *src);             <span class="comment">// IFF (1&lt;&lt;25)</span></span><br><span class="line">        <span class="comment">// required ABI.2010.3.16</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *signature;                         <span class="comment">// IFF (1&lt;&lt;30)</span></span><br><span class="line">    &#125; *descriptor;</span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从这个结构体的第一个元素，我看到了一个熟悉的变量名 “isa”，和 objc class的 isa指针作用类似，表明了 Block的类型。从注释可以得知 Block的 isa指针初始化的时候可能指向的是 _NSConcreteStackBlock 或 _NSConcreteGlobalBlock，这表示 Block在刚创建的时候的内存类型，可能是 栈上的，也可能是全局的。</p>
<p>不过，Clang文档没有提到的其他的类型，从最新的 <a href="https://opensource.apple.com/tarballs/libclosure/" target="_blank" rel="noopener">libclosure</a>的源代码 可以得知，其实 Block的类型是有下面这几种的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * _NSConcreteStackBlock[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">void</span> * _NSConcreteMallocBlock[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">void</span> * _NSConcreteAutoBlock[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">void</span> * _NSConcreteFinalizingBlock[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">void</span> * _NSConcreteGlobalBlock[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">void</span> * _NSConcreteWeakBlockVariable[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>Block 的 isa最终会指向他们其中一个指针数组的首地址，这样一来，比较 Block的类型就是比较不同的指针，会比较方便一点。</p>
<p>不过我们常见的是 _NSConcreteStackBlock，_NSConcreteGlobalBlock, _NSConcreteMallocBlock, 把 Block想象成普通的变量我们就可以理解了，因为我们所用的变量要么是 栈上的，要么是全局的，要么就是堆上的。至于其他三种类型，那是 GC所需要关心的事，暂时和我们无关，先放一边。</p>
<p>再看看 Block 结构里的第二个元素 flag，很明显 libclosure的大神们在这里立了一个 flag，以便生成 Block后在运行时知道一些具体的信息，从 runtime源码看到了如下定义（此 runtime为 libclosure的 runtime）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BLOCK_DEALLOCATING =      (<span class="number">0x0001</span>),  <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_REFCOUNT_MASK =     (<span class="number">0xfffe</span>),  <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_NEEDS_FREE =        (<span class="number">1</span> &lt;&lt; <span class="number">24</span>), <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_HAS_COPY_DISPOSE =  (<span class="number">1</span> &lt;&lt; <span class="number">25</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_HAS_CTOR =          (<span class="number">1</span> &lt;&lt; <span class="number">26</span>), <span class="comment">// compiler: helpers have C++ code</span></span><br><span class="line">    BLOCK_IS_GC =             (<span class="number">1</span> &lt;&lt; <span class="number">27</span>), <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_IS_GLOBAL =         (<span class="number">1</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_USE_STRET =         (<span class="number">1</span> &lt;&lt; <span class="number">29</span>), <span class="comment">// compiler: undefined if !BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    BLOCK_HAS_SIGNATURE  =    (<span class="number">1</span> &lt;&lt; <span class="number">30</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_HAS_EXTENDED_LAYOUT=(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)  <span class="comment">// compiler</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从这些 enum的注释可以得知，一些是运行时用的，还有一些是编译时期就会产生的，在讨论 Block如何运行（或者说讨论编程语言的函数运行）之前，就先不看这些运行时选项了。那么很明显看到这个 flag会标记 Block是否 Global的，是否需要 Copy和 Dispose，是否带返回值的调用（STRET），是否有函数签名（SIGNATURE），以及是否有一些额外的“布局”（EXTENDED_LAYOUT），比如说传入的参数，这个稍后讨论。</p>
<p>“先在本文中立个 flag，以后要专门开一篇文章来描述函数的运行”</p>
<p>不过文档里还提到，关于上文中这个 Block flag的 enum中的一些值其实是历史遗留的，有点冗余的意味，但又不能删，因为 C语言的 ABI已经稳定若干年了。比如 BLOCK_USE_STRET 和 BLOCK_HAS_SIGNATURE总是成对出现的，而大部分时候进行调用的时候，调用者需要知道的只是一个函数签名，至于返回值，从标准的 Call Interface很容易就能获得，类型在函数签名甚至调用者自己也是十分清楚的。</p>
<p>说到这儿，我想有必要描述一下函数签名的作用。当进程被启动时，也就是 main函数执行时显而易见是有参数传进来的，但参数是不定长的。同样的道理，进程内的函数调用本质上的参数传递也是不定长的，调用者只有知道目标函数的函数签名，才能确定传多少参数，每个参数类型是什么。所以这同样解释了 Global类型的 Block为啥没有方法签名。因为它无参数，无返回值（或者说返回值是 void），调用者只需要知道函数执行的首地址就可以了。突然提到这个 Global类型的 Block，我们稍后再慢慢来看一下 Block的具体实现。</p>
<p>先继续 flag后面的变量，叫 reserved, 很显然这是一个保留字，用作什么也不清楚，不过从编译期的传值来看，都是0，并没有实际用它的地方，也没有注释说将来可能会用作什么，所以在遇到保留字的时候，跳过阅读就好了。不过我的猜想是 flag字段是通过左移右移计算的，所以很可能是怕内存溢出影响到实际的函数指针指向，那样就会影响 Block的实际执行，麻烦就大了。</p>
<p>我们接着看后一个字段 invoke，顾名思义即实际的函数指针，这没什么好说的。再接下来一段结构体把一些关于这个 Block的一些描述或者其他用得到的 “context”给记录下来。开头便是一个保留字，然后是 Block的 size，接下来是有可能出现的两个函数指针，copy 和 dispose，帮助管理 Block变量的引用计数，他们俩仅有可能在 flag出现 BLOCK_HAS_COPY_DISPOSE 即 (flag &amp; 1&lt;&lt;25) 时会存在。然后是 Block的方法签名，也仅当 BLOCK_HAS_SIGNATURE时才会存在。最后一行注释告诉我们，那块内存会存在一些捕获的变量。</p>
<p>刚才这段其实从字面上看会让人糊里糊涂，好在 Clang文档给我们提供了一个例子，关于在 32位系统下改写 objc为 C++的一个实现，同样地，我们自己也可以使用 Clang工具改写，具体的命令是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang --rewrite-objc [input_file]</span><br></pre></td></tr></table></figure>
<p>我这边直接拿官方文档的例子，比较清晰一些：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before rewrite</span></span><br><span class="line">^ &#123; <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//after rewrite</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_literal_1</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> (*invoke)(struct __block_literal_1 *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_descriptor_1</span> *<span class="title">descriptor</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//注释 1</span></span><br><span class="line"><span class="keyword">void</span> __block_invoke_1(struct __block_literal_1 *_block) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">block_descriptor_1</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> Block_size;</span><br><span class="line">&#125; __block_descriptor_1 = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __block_literal_1), __block_invoke_1 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注释 2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_literal_1</span> _<span class="title">block_literal</span> = &#123;</span></span><br><span class="line">     &amp;_NSConcreteStackBlock,</span><br><span class="line">     (<span class="number">1</span>&lt;&lt;<span class="number">29</span>), &lt;uninitialized&gt;,</span><br><span class="line">     __block_invoke_1,</span><br><span class="line">     &amp;__block_descriptor_1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>仔细看这一段重写后的代码，重写前的 Block没有返回值，没有传参，然后 Block的实际执行体被重写成了一个 C函数，传参为 Block的结构自身（详见注释1）。然后实际的 Block变量被声明为 _NSConcreteStackBlock，flag设置为 1&lt;&lt;29，invoke指针指向了执行函数，descriptor指针指向了前一步生成的结构体。（1&lt;&lt;29 flag 在运行时通常被忽略，所以这样赋值并没有什么特殊意义，避免 uninitialized这样设置 flag也可以理解）。</p>
<p>Clang文档中提到了关于 Block的 isa类型的问题，这里也表明了他们在设计 Block时候的初衷：当一个 Block的字面量声明在全局或声明为 static的时候，isa是指向 _NSConcreteGlobalBlock的。除此之外，Block在初始化时的 isa都是指向 _NSConcreteStackBlock的，缺点就非常明显了，只存在于栈帧中，内存清除后肯定就无法引用到了，所以 libclosure中有 Block_Copy()方法将 Block拷贝到堆上，这时候 isa便指向了 _NSConcreteMallocBlock。文档虽然说了只有有限的一两种情况下 Block是全局的，但显然在 ARC时代 LLVM的实现并未如此，如果Block定义在局部（函数体内部）且未捕获自动变量，那么这些 Block也是全局类型的。那么捕获了自动变量呢？显然就会变成堆上的 Block，栈上的 Block在 ARC下貌似是不存在的（不过从最新的 LLVM文档发现，ARC下，Block初始化时是栈类型的，但如果引用或返回，会移动到堆上，所以“栈上的 Block在 ARC下不存在勉强不算错”）。</p>
<p>我们接下来看一下 Block捕获变量的方式是如何影响到 ARC时代的 Block内存管理的。</p>
<p>Clang文档提到，捕获没有标记 __block的变量时，直接导入了该变量的 const Copy，比如文档中的这个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span> (^vv)(<span class="keyword">void</span>) = ^&#123; <span class="built_in">printf</span>(<span class="string">"x is %d\n"</span>, x); &#125;</span><br><span class="line">x = <span class="number">11</span>;</span><br><span class="line">vv();</span><br></pre></td></tr></table></figure>
<p>会被 Clang重写为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_literal_2</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> (*invoke)(struct __block_literal_2 *);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">block_descriptor_2</span> *<span class="title">descriptor</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __block_invoke_2(struct __block_literal_2 *_block) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"x is %d\n"</span>, _block-&gt;x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">block_descriptor_2</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> Block_size;</span><br><span class="line">&#125; __block_descriptor_2 = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __block_literal_2) &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_literal_2</span> __<span class="title">block_literal_2</span> = &#123;</span></span><br><span class="line">      &amp;_NSConcreteStackBlock,</span><br><span class="line">      (<span class="number">1</span>&lt;&lt;<span class="number">29</span>), &lt;uninitialized&gt;,</span><br><span class="line">      __block_invoke_2,</span><br><span class="line">      &amp;__block_descriptor_2,</span><br><span class="line">      x</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>所以在 Block执行的时候并不能更改这些变量，这也解释了 Block为什么不需要 discriptor里面的 helper functions 来帮助管理变量的引用计数。总结来说，纯量类型、结构体、联合体以及函数指针，都只会传递一份 const copy给 Block引用。</p>
<p>但当 const copy的对象是另一个 Block时，情况就稍微麻烦一点，首先 Block的实际存在形式是一个结构体指针，前面说过纯量类型会直接传递一个 const copy过的值进来，对于 Block，这个 const结构体指针传进来时在 runtime并不能直接用，因为你并不能保证这个指针指向的 Block能正确执行，万一这个 Block在栈上早就释放了呢？所以这时候 Block的 descriptor就会产生 copy_helper和 dispose_helper，把传递进来的指针对应的内存 copy一份到堆上，保持正确的引用，并且在使用结束后正确释放内存。这一段逻辑在文档中有对应的 <a href="https://clang.llvm.org/docs/Block-ABI-Apple.html#imported-const-copy-of-block-reference" target="_blank" rel="noopener">rewrite代码</a> 。同样地对于 objc的对象类型，和 Block类型一样被 Block捕获时会被 copy一次，为了让 C类型认识除了 Block被 copy还有 Object也会被 copy，在执行 copy helper function的时候还会为 Object类型填上一个类型叫 BLOCK_FIELD_IS_OBJECT，以便后续 context执行时不要把它误认为一个 Block。</p>
<p>如上所述的话其实 Block捕获变量还算简单，但我们忘了一点，大部分时候我们把 Block作为回调使用，需要去改变外部变量的值，一个 const copy根本满足不了需求，而且我们平时写的时候也知道，需要外部变量被改变，那么需要加上 __block这样一个标记，那么这个标记是怎样的原理呢？文档同样也有介绍。</p>
<p>__block标记的变量会被改造得面目全非，在 libclosure和 Clang文档里都有介绍变量被改写后的内存布局：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">block_byref_foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *<span class="title">forwarding</span>;</span></span><br><span class="line">    <span class="keyword">int</span> flags;   <span class="comment">//refcount;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// helper functions called via Block_copy() and Block_release()</span></span><br><span class="line">    <span class="keyword">void</span> (*byref_keep)(<span class="keyword">void</span>  *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*byref_dispose)(<span class="keyword">void</span> *);</span><br><span class="line">    typeof(marked_variable) marked_variable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到一个变量会被重写成这个鬼样子，关于这些变量的初始化顺序是这样的：</p>
<p>forwarding指向自己这个结构体的开始地址<br>size变量被设置为结构体的大小<br>flags被设置为0或 1&lt;&lt;25（如果需要 helper_functions的话）<br>helper_functions初始化 （if needed）<br>marked_variable设置为捕获变量的值<br>isa设置为 NULL<br>Block内部在调用这个变量时就是这样的</p>
<p>variable-&gt;forwarding.marked_variable = someValue;</p>
<p>和捕获非 __block标记变量类似，此处也有关于 Block类型和 Object类型的困扰。比如一个 Block类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__block <span class="title">void</span> <span class="params">(voidBlock)</span><span class="params">(<span class="keyword">void</span>)</span> </span>= blockA;</span><br><span class="line">voidBlock = blockB;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rewrited</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">block_byref_voidBlock</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_byref_voidBlock</span> *<span class="title">forwarding</span>;</span></span><br><span class="line">    <span class="keyword">int</span> flags;   <span class="comment">//refcount;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">void</span> (*byref_keep)(struct _block_byref_voidBlock *dst, struct _block_byref_voidBlock *src);</span><br><span class="line">    <span class="keyword">void</span> (*byref_dispose)(struct _block_byref_voidBlock *);</span><br><span class="line">    <span class="keyword">void</span> (^captured_voidBlock)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _block_byref_keep_helper(struct _block_byref_voidBlock *dst, struct _block_byref_voidBlock *src) &#123;</span><br><span class="line">    <span class="comment">//_Block_copy_assign(&amp;dst-&gt;captured_voidBlock, src-&gt;captured_voidBlock, 0);</span></span><br><span class="line">    _Block_object_assign(&amp;dst-&gt;captured_voidBlock, src-&gt;captured_voidBlock, BLOCK_FIELD_IS_BLOCK | BLOCK_BYREF_CALLER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _block_byref_dispose_helper(struct _block_byref_voidBlock *param) &#123;</span><br><span class="line">    <span class="comment">//_Block_destroy(param-&gt;captured_voidBlock, 0);</span></span><br><span class="line">    _Block_object_dispose(param-&gt;captured_voidBlock, BLOCK_FIELD_IS_BLOCK | BLOCK_BYREF_CALLER)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//usage</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">block_byref_voidBlock</span> <span class="title">voidBlock</span> = &#123;</span>( .forwarding=&amp;voidBlock, .flags=(<span class="number">1</span>&lt;&lt;<span class="number">25</span>), .size=<span class="keyword">sizeof</span>(struct _block_byref_voidBlock *),</span><br><span class="line">    .byref_keep=_block_byref_keep_helper, .byref_dispose=_block_byref_dispose_helper,</span><br><span class="line">    .captured_voidBlock=blockA )&#125;;</span><br><span class="line"></span><br><span class="line">voidBlock.forwarding-&gt;captured_voidBlock = blockB;</span><br></pre></td></tr></table></figure>
<p>很显然，Block作为一种引用类型，在标记为 __block后，会被 copy到堆上，由捕获的 Block管理内存，可想而知，Object类型也是基本一致的。</p>
<p>看了这么多，很容易总结出 Block对变量的捕获规则：</p>
<ol>
<li><p>最简单的是 全局变量和 static变量，随意引用和修改，在任何地方都是如此。</p>
</li>
<li><p>上下文变量，也就是栈变量，const copy，不可修改。前面也提到在 ARC下，为了保持 Block的生命周期，便于自动管理，Block会被 copy到堆上（实际上 Block被概念化为一个引用类型或对象）。但此时 Block在捕获引用类型就会产生强引用</p>
</li>
<li>__block标记的上下文变量，会从栈变量挪到堆，以保证完整的生命周期访问。除了要担心循环引用外，剩下的事都可以交给 ARC打扫。</li>
</ol>
<p>ARC为我们隐藏了太多的细节，其实我们大可不必关心 Block的具体实现。但如果担心的话，跑过来看一遍，在写相关代码时可能会更有信心一点。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/06/19/nsrunloop/" class="prev">PREV</a></div><div class="copyright"><p>© 2015 - 2021 <a href="https://stephenwzl.github.io">stephenwzl</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>