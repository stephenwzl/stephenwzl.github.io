<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Flutter Dart Framework原理简解 · stephenwzl</title><meta name="description" content="Flutter Dart Framework原理简解 - stephenwzl"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avatar.png"><link rel="stylesheet" href="/css/apollo-v1.css"><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-118080805-1"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-118080805-1');</script><link rel="search" type="application/opensearchdescription+xml" href="https://stephenwzl.github.io/atom.xml" title="stephenwzl"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/wangzhilong110" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/stephenwzl" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Flutter Dart Framework原理简解</h1><div class="post-info">May 28, 2018</div><div class="post-content"><p><img src="/images/flutter-dart-framework-cover.jpg" alt></p>
<p>从前一篇文章<a href="/2018/05/14/flutter-principle/">Flutter原理</a>的分析可知，Flutter Engine向 <code>dart:ui</code> Framework层提供了通用的绘图能力，Flutter渲染 UI的本质就是在 VSync信号间尽快地构建并提供视图数据。所以 Flutter整个框架的精髓在 Dart UI Framework（更准确地叫作 Flutter Dart Framework）里，这里面涉及了非常多的设计思想、优化措施，所以一篇文章是无法概括的。 所以在本篇文章中，我们只能概要性地分析一下 Flutter Dart Framework的大致原理。</p>
<a id="more"></a>
<h1 id="UI框架绘图的基本流程"><a href="#UI框架绘图的基本流程" class="headerlink" title="UI框架绘图的基本流程"></a>UI框架绘图的基本流程</h1><p>在开始本文前，我们还是要了解一下通用的 UI框架绘图的流程，以便我们理解 Flutter的 Dart Framework：</p>
<p><img src="/images/render-pipeline.png" alt></p>
<p>从上图中我们可以看到，用户的输入才是驱动视图更新的信号。当这个信号发生后，首先需要触发的就是动画的进度更新，框架需要开始视图数据的“build”（也可以看做数据的填充）。<br>在这之后，视图才会进行布局，计算各个部分的大小，然后进行“paint”，生成每个视图的视觉数据。生成的视觉数据并不能直接用，因为往往视图层级非常多， 这些数据直接向 GPU传递很低效，所以接下来需要进行视图合成，将多个视图数据合成为一个。<br>最后一步进行“光栅化”，前一步得到合成的视图数据其实还是一份矢量描述数据，光栅化帮助把这份数据真正地生成一个一个的像素填充数据。在 Flutter中，光栅化这个步骤被放在了 Engine中，但是我们前文并没有提到。  </p>
<p>在了解 UI框架的通用流程后，我们自然而然能知道 Flutter Dart Framework这一层肯定做了以下这些事：</p>
<ol>
<li>视图的数据结构（视图树）</li>
<li>视图数据的构建 </li>
<li>视图布局的计算 </li>
<li>视图的合成</li>
<li>与 Engine的数据同步和通信</li>
</ol>
<h1 id="视图的结构"><a href="#视图的结构" class="headerlink" title="视图的结构"></a>视图的结构</h1><p>无论是比较底层的 UI框架（如 Cocoa、WebKit）还是比较上层的 （React），在向绘制引擎提供视图数据都需要一份结构化的视图数据，俗称为“视图树”(View Tree)。Flutter 的视图结构的抽象分为三部分：<code>Widget</code>, <code>Element</code>, <code>RenderObject</code>。  </p>
<blockquote>
<p>三部分？在哪熟悉是不是？ Cocoa Touch中，视图树被分为 模型树、呈现树、渲染树， 在 Flutter中你也可以看待这三部分的意义。</p>
</blockquote>
<h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget:"></a><strong>Widget</strong>:</h2><p>Widget是 Flutter中控件实现的基本单位，其意义类似于 Cocoa Touch中的 UIView。Widget里面存储了一个视图的配置信息，包括布局、属性等待。所以它只是一份轻量的，可直接使用的数据结构。在构建为结构树，甚至重新创建和销毁结构树时都不存在明显的性能问题。  </p>
<h2 id="Element"><a href="#Element" class="headerlink" title="Element:"></a><strong>Element</strong>:</h2><p>Element是 Widget的抽象，它其实承载了视图构建的上下文数据。构建系统通过遍历 Element树来构建 RenderObject数据，比如视图更新时，只会标记 dirty Element，而不会标记 dirty Widget。所以 Widget“无状态”，而 Element“有状态” （这个状态指框架层的构建状态）。</p>
<h2 id="RenderObject"><a href="#RenderObject" class="headerlink" title="RenderObject:"></a><strong>RenderObject</strong>:</h2><p>在 RenderObject树中会发生 Layout、Paint的绘制事件，所以 Flutter中大部分的绘图性能优化发生在这里。RenderObject树构建的数据会被加入到 Engine所需的 LayerTree中，Engine通过 LayerTree进行视图合成并光栅化，提交给 GPU。  </p>
<p>Flutter通过这三种概念，把原本比较复杂的视图树状态、数据的维护和构建拆分得更单一、易于集中治理。</p>
<h1 id="视图数据的构建"><a href="#视图数据的构建" class="headerlink" title="视图数据的构建"></a>视图数据的构建</h1><p>这个话题其实比较大，涉及到的逻辑也很多。我们可以先从应用入口开始看起。</p>
<h2 id="应用的-root-view"><a href="#应用的-root-view" class="headerlink" title="应用的 root view"></a>应用的 root view</h2><p>Flutter App 入口的部分发生于如下代码：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 MyApp是一个 Widget</span></span><br><span class="line"><span class="keyword">void</span> main() =&gt; runApp(<span class="keyword">new</span> MyApp());</span><br></pre></td></tr></table></figure>
<p><code>runApp</code>函数接受一个 Widget类型的对象作为参数，也就是说在 Flutter的概念中，只存在 View，而其他的任何逻辑都只为 View的数据、状态改变服务，不存在 ViewController(或者叫 Activity）。<br>接下来看 <code>runApp</code>做了什么：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">    ..attachRootWidget(app)</span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsFlutterBinding</span> <span class="keyword">extends</span> <span class="title">BindingBase</span> <span class="title">with</span> <span class="title">GestureBinding</span>, <span class="title">ServicesBinding</span>, <span class="title">SchedulerBinding</span>, <span class="title">PaintingBinding</span>, <span class="title">RendererBinding</span>, <span class="title">WidgetsBinding</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">    <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">new</span> WidgetsFlutterBinding();</span><br><span class="line">    <span class="keyword">return</span> WidgetsBinding.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>runApp</code>中，传入的 widget被挂载到根 widget上。这个 <code>WidgetsFlutterBinding</code>其实是一个单例，通过 mixin来使用框架中实现的其他 binding的 Service，比如 手势、基础服务、队列、绘图等等。然后会调用 <code>scheduleWarmUpFrame</code>这个方法，从这个方法注释可知，调用这个方法会主动构建视图数据。这样做的好处是因为 Flutter依赖 Dart的 MicroTask来进行帧数据构建任务的 schedule，这里通过主动调用进行整个周期的 “热身”，这样最近的下次 VSync信号同步时就有视图数据可提供，而不用等到 MicroTask的 next Tick。  </p>
<p>然后我们再来看 <code>attachRootWidget</code>这个函数干了什么：  </p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    _renderViewElement = <span class="keyword">new</span> RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">      container: renderView,</span><br><span class="line">      debugShortDescription: <span class="string">'[root]'</span>,</span><br><span class="line">      child: rootWidget</span><br><span class="line">    ).attachToRenderTree(buildOwner, renderViewElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>attachRootWidget</code>把 widget交给了 <code>RenderObjectToWidgetAdapter</code>这座桥梁，通过这座桥梁，Element被创建，并且同时能持有 Widget和 RenderObject的引用。然后我们从上文就知道后面发生的就是第一次的视图数据构建了。   </p>
<p><strong>从这一部分能印证前面所说：Flutter应用通过 <code>Widget</code>、<code>Element</code>、<code>RenderObject</code> 三种树结构来维护整个应用的视图数据。</strong>  </p>
<h2 id="视图数据的构建时机"><a href="#视图数据的构建时机" class="headerlink" title="视图数据的构建时机"></a>视图数据的构建时机</h2><p>VSync信号其实在 Flutter Dart Framework层是透明的，视图的数据构建和更新并不是由 VSync信号驱动的。我在前文说道： <strong>Flutter并不关心显示器、视频控制器以及 GPU具体工作，它只关心 GPU发出的 VSync信号，尽可能快地在两个 VSync信号之间计算并合成视图数据，并且把数据提供给 GPU。</strong> 这个说法其实是不准确的，准确的说法其实应该是：  </p>
<p>Flutter 并不关心显示器、视频控制器以及 GPU具体工作，它只关心能在 VSync信号间隔时间内尽快地合成视图数据，等待 VSync信号同步来获取这个视图数据提供给 GPU。</p>
<p>那么 Flutter是在什么时机构建视图数据的呢？前面就已经揭晓过答案：MicroTask 循环。  </p>
<blockquote>
<p>是不是和 Cocoa Touch很像？NSRunloop 的 main loop 也是通过事件循环来执行固定的视图更新回调</p>
</blockquote>
<p><code>dart:ui</code>有一个抽象的 <code>window</code>，它并不负责向 LayerTree提供数据，但在 Flutter中，它承担了管理和回调视图更新方法的重担。在 rootView(rootElement)被创建时，ScheduleBinding便会调用 <code>scheduleFrame</code>，这会调用 <code>window.scheduleFrame</code>，而在 window 的 postFrameCallback 中，<code>scheduleFrame</code>会再次被调用，这样就形成了循环。  </p>
<p>通过这种有序的周期循环，Flutter能源源不断地提供帧视图数据，VSync信号同步时便能获得这个数据进行 Engine部分后续的操作。</p>
<h2 id="视图数据的构建方式"><a href="#视图数据的构建方式" class="headerlink" title="视图数据的构建方式"></a>视图数据的构建方式</h2><p>前面提到，视图树被分为三类： <code>Widget</code>、<code>Element</code>、<code>RenderObject</code>，Element同时持有 Widget和 RenderObject的引用。这是本段的大前提。<br>Widget是用户能够直接操作的数据结构，Flutter的设计理念中，Widget都是 immutable的，所以 Widget节点的改变其实就是节点的销毁和重新创建。但如果只是最基本的 Widget手动组合的话，写起来会很蛋疼，所以 Flutter使用 State来控制 Widget的创建与销毁，以此来达到响应式 UI编程的目的。  </p>
<blockquote>
<p>细细品味，Widget的设计理念有没有一点和 React像？</p>
</blockquote>
<p>Widget在更新后，Element持有该 Widget的节点也会被标记为 dirtyElement，那么在下一个周期的 drawFrame时，Element树的这一部分子树便会被触发 performRebuild。在 Element树更新完成后，便能获得 RenderObject树，接下来便会进入 Layout和 Paint的流程。</p>
<h1 id="视图的布局与绘制"><a href="#视图的布局与绘制" class="headerlink" title="视图的布局与绘制"></a>视图的布局与绘制</h1><p>在 Flutter中，视图的布局与合成是整个 UI框架中最重要的部分，这部分的好坏决定了绘图的性能以及框架的应用表现，所以 Google有一个专门的 TechTalk来讲解这个原理：<a href="https://www.youtube.com/watch?v=UUfXWzp0-DU" target="_blank" rel="noopener">Flutter’s renderding pipeline</a>  </p>
<p><img src="/images/flutter-pipeline.png" alt>  </p>
<h2 id="布局的计算"><a href="#布局的计算" class="headerlink" title="布局的计算"></a>布局的计算</h2><p>要获得每个 Widget的真实视图数据，布局是第一步。布局可以计算出每个节点所占空间的真实大小。在构建视图树时，节点的 size约束是从树顶部向底部的，而在计算布局的时候，遍历树是深度优先，所以获得布局数据的顺序是自下而上的。和 Web一样，Flutter的布局也是基于盒子模型，并且参考了众多布局方案设计而成 （毕竟负责这一部分的 Adam Barth也是 Blink项目的核心开发者)，这部分的核心设计比较复杂，我们完全可以另开一篇文章，这里不再展开。<br><img src="/images/layout-data-flow.png" alt>  </p>
<h2 id="视图的绘制"><a href="#视图的绘制" class="headerlink" title="视图的绘制"></a>视图的绘制</h2><p>绘制决定了一个视图节点的真实外观。和布局不太一样的是绘制的顺序，布局会优先计算子节点，而绘制会优先绘制父节点。所以在数据流上看起来两个流程的方向是相反的。</p>
<p><img src="/images/paint-data-flow.png" alt>  </p>
<p>绘制要做的事就是计算出一个 Layer的外观，这通常都不简单，因为开发者经常会在视图上放各种各样的控件，并且他们的层级也不一样，所以绘制的步骤要做的事情就是决定一个 Layer的某一部分长什么样，这也可以看做视图的局部合成。举个例子：  </p>
<p><img src="/images/paint-into-layers.png" alt></p>
<p>在进行绘制时，每个节点都会先绘制自身，其次才是子节点。比如节点 2是一个背景色绿色的视图，在绘制完自身后，绘制子节点 3和 4，它们可能具有 alpha属性，所以绘制后当布局重叠时会合成红色的节点 5。所以从数据流方向看的时候，获得最终的 Layer的顺序反而是自下而上的。<br><img src="/images/paint-target-layer-flow.png" alt>  </p>
<blockquote>
<p>一个 Layer是一份矢量数据，挂载到 LayerTree后还会经过 Engine的合成和光栅化才能提交给 GPU。RenderObject并不是和 Layer一一对应的，所以需要 paint过程将 RenderObject转化为 Layer</p>
</blockquote>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>视图树会不断更新，这就意味着布局和绘制是不间断的。我们上面提到的布局和绘制只是九牛一毛，Flutter其实在这方面做了很多事情，不间断的布局和绘制肯定会非常耗费性能，所以 Flutter也有对应的优化方案（在 Flutter的布局和绘制算法足够优秀的前提下）。  </p>
<p><strong>边界</strong>：Flutter使用边界标记需要重新布局和重新绘制的节点部分，这样就可以避免其他节点被污染或者触发重建，这个边界被分别叫做 Relayout boundary 和 Repaint boundary。<br><img src="/images/relayout-boundary.png" width="300px"><br><img src="/images/repaint-boundary.png" width="300px"> </p>
<p><strong>缓存</strong>：要提升性能表现，缓存也是少不了的。在 Flutter中，几乎所有的 Element都会具有一个 key，这个 key是唯一的。当子树重建后，只会刷新 key不同的部分。而节点数据的复用就是依靠 key来从缓存中取得。</p>
<blockquote>
<p>Flutter 的渲染机制可以当做一本教科书，本文只能管中窥豹了</p>
</blockquote>
<h2 id="挂载-LayerTree"><a href="#挂载-LayerTree" class="headerlink" title="挂载 LayerTree"></a>挂载 LayerTree</h2><p><code>Layer</code>的抽象在 Flutter中是真实存在的，<code>RenderObject</code>在经过 paint生成 Layer后，会通过 <code>dart:ui</code>的 <code>SceneBuilder</code>挂载到 LayerTree。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Override this method to upload this layer to the engine.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The `layerOffset` is the accumulated offset of this layer's parent from the</span></span><br><span class="line"><span class="comment">/// origin of the builder's coordinate system.</span></span><br><span class="line"><span class="keyword">void</span> addToScene(ui.SceneBuilder builder, Offset layerOffset);</span><br></pre></td></tr></table></figure>
<p>这是一个抽象接口，不同的 Layer（如 ContainerLayer、TextureLayer等）在继承抽象类后自行处理逻辑，但无外乎都会最终调用 <code>builder.addXXX</code>这类方法，把传递的 Layer真正地挂载上去。</p>
<blockquote>
<p>接下来的事情上一篇文章也提过了，Skia在 VSync信号同步时直接从 LayerTree合成 Bitmap，（经过光栅化后）提交给 GPU</p>
</blockquote>
<h1 id="Flutter-的通信机制"><a href="#Flutter-的通信机制" class="headerlink" title="Flutter 的通信机制"></a>Flutter 的通信机制</h1><p>读完上面大概能了解到 Flutter怎么通过固定的数据结构构建并渲染丰富多彩的视图。但文章开头说过，用户输入才是驱动视图更新的源泉，所以需要专门讨论一下 Flutter是如何获得用户输入并与平台通信的。  </p>
<h2 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h2><p>在当今的移动设备上传感器有很多，屏幕输入也可以算作一种。所以这里以讨论手势输入为例。<br>Flutter通过 Native方法捕捉用户的屏幕输入，这些数据被封装成一个一个的数据包，通过 Dart的 runtime hook发送给 <code>dart:ui</code>中的 <code>_dispatchPointerDataPacket</code>方法。这个方法会直接将屏幕输入数据分发给 <code>window</code>，所以在 Flutter中，我们可以将触摸时间看作发生在全局的 <code>window</code>上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Shell</span></span><br><span class="line"><span class="comment">// 将封装好的手势数据 packet发送给 engine</span></span><br><span class="line">blink::Threads::UI()-&gt;PostTask(fxl::MakeCopyable(</span><br><span class="line">      [ engine = _platformView-&gt;engine().GetWeakPtr(), packet = <span class="built_in">std</span>::move(packet) ] &#123;</span><br><span class="line">        <span class="keyword">if</span> (engine.get())</span><br><span class="line">          engine-&gt;DispatchPointerDataPacket(*packet);</span><br><span class="line">      &#125;));</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="comment">// engine直接 通过 libtonic hook Dart的 _dispatchPointerDataPacket 方法将数据包传递过去</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RuntimeController::DispatchPointerDataPacket</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> PointerDataPacket&amp; packet)</span> </span>&#123;</span><br><span class="line">  TRACE_EVENT1(<span class="string">"flutter"</span>, <span class="string">"RuntimeController::DispatchPointerDataPacket"</span>,</span><br><span class="line">               <span class="string">"mode"</span>, <span class="string">"basic"</span>);</span><br><span class="line">  GetWindow()-&gt;DispatchPointerDataPacket(packet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Window::DispatchPointerDataPacket</span><span class="params">(<span class="keyword">const</span> PointerDataPacket&amp; packet)</span> </span>&#123;</span><br><span class="line">  tonic::DartState* dart_state = library_.dart_state().get();</span><br><span class="line">  <span class="keyword">if</span> (!dart_state)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  tonic::<span class="function">DartState::Scope <span class="title">scope</span><span class="params">(dart_state)</span></span>;</span><br><span class="line"></span><br><span class="line">  Dart_Handle data_handle = ToByteData(packet.data());</span><br><span class="line">  <span class="keyword">if</span> (Dart_IsError(data_handle))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  DartInvokeField(library_.value(), <span class="string">"_dispatchPointerDataPacket"</span>,</span><br><span class="line">                  &#123;data_handle&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Flutter在接收到数据包后，识别触摸点发生的坐标，通过数学计算来识别手势。这和 Native框架的逻辑几乎是一样的。</p>
<h2 id="Native通信"><a href="#Native通信" class="headerlink" title="Native通信"></a>Native通信</h2><p>但除了手势这种特定的输入，还有其他传感器和事件的传递被抽象得更通用，叫做 <code>MethodChannel</code>。这样就可以避免用户每次需要开发一个 Native extension时都要写 Native Binding了。 MethodChannel的原理和手势的传递几乎是一样的，但是 API会更通用一点。<br><img src="/images/PlatformChannels.png" alt>  </p>
<p>在这篇教程中 <a href="https://flutter.io/platform-channels" target="_blank" rel="noopener">PlatformChannels</a>示例了一个如何通过 Native 获取电池电量，并通过 PlatformChannel传递给 Flutter应用。而这个 PlatformChannel像手势数据分发那样，换了一个方法：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Window::DispatchPlatformMessage</span><span class="params">(fxl::RefPtr&lt;PlatformMessage&gt; message)</span> </span>&#123;</span><br><span class="line">  tonic::DartState* dart_state = library_.dart_state().get();</span><br><span class="line">  <span class="keyword">if</span> (!dart_state)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  tonic::<span class="function">DartState::Scope <span class="title">scope</span><span class="params">(dart_state)</span></span>;</span><br><span class="line">  Dart_Handle data_handle =</span><br><span class="line">      (message-&gt;hasData()) ? ToByteData(message-&gt;data()) : Dart_Null();</span><br><span class="line">  <span class="keyword">if</span> (Dart_IsError(data_handle))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> response_id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> response = message-&gt;response()) &#123;</span><br><span class="line">    response_id = next_response_id_++;</span><br><span class="line">    pending_responses_[response_id] = response;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DartInvokeField(</span><br><span class="line">      library_.value(), <span class="string">"_dispatchPlatformMessage"</span>,</span><br><span class="line">      &#123;ToDart(message-&gt;channel()), data_handle, ToDart(response_id)&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种打开一个 Channel来进行 request/response 的抽象概念可以实现任何用户自定义的 extension。</p>
<h1 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h1><p>Flutter是 engine和 Dart Framework的统称，目前 Flutter还处于 beta阶段，虽然说大致原理不会变，但一些细节部分还是会有不少改动。本文只能看个大概，因为，信息量实在是太大了。<br>好了，原理分析告一段落，在后面的使用中，我们再来细细探讨 Flutter的一些设计理念。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/03/ios-flutter-integrate/" class="prev">PREV</a><a href="/2018/05/14/flutter-principle/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2021 <a href="https://stephenwzl.github.io">stephenwzl</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>