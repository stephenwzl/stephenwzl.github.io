<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 了解 Clang AST · stephenwzl</title><meta name="description" content="了解 Clang AST - stephenwzl"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/avatar.png"><link rel="stylesheet" href="/css/apollo-v1.css"><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-118080805-1"></script><script type="text/javascript">window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-118080805-1');</script><link rel="search" type="application/opensearchdescription+xml" href="https://stephenwzl.github.io/atom.xml" title="stephenwzl"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/wangzhilong110" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/stephenwzl" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">了解 Clang AST</h1><div class="post-info">Jan 8, 2018</div><div class="post-content"><p>Clang 作为 世界上最好的编译器前端（可能没有之一），散发着独特的令人着迷的魅力，让人无法抗拒想去更多地了解它。<br>通过本文，你大概能知道：</p>
<ul>
<li>什么是 Clang AST</li>
<li>Clang AST 有那些东西</li>
<li>怎么搭建 LLVM/Clang开发环境</li>
<li>站在巨人的肩膀上（通过 Clang提供的功能编写一个小工具）</li>
</ul>
<p>跟随本文的教程，你可能需要以下的基础准备：</p>
<ul>
<li>有基本的 C/C++编程基础</li>
<li>直接或间接地使用过 Clang，看得懂一些命令行参数是干什么的</li>
<li>有一点抽象编程的思考能力</li>
</ul>
<a id="more"></a>
<h1 id="什么是-Clang-AST"><a href="#什么是-Clang-AST" class="headerlink" title="什么是 Clang AST"></a>什么是 Clang AST</h1><p>大家都知道 AST（Abstract Syntax Tree）是编译前端执行过程中必不可少的中间产物，你写的代码被编译器前端翻译成了一种抽象的，可用有限的语言描述的树状结构的东西。<br>Clang AST也没有脱离这个本质，但它跟其他编译器所生成的 AST相比多了很多非常有用的东西，这些东西可以让 Clang AST表现得就像普通的 C++代码变量，让操作 AST和从 AST获取信息非常变得非常容易。</p>
<p>不过在深入了解 Clang AST前，我们适当补充一些 AST相关的知识：如何用 AST来表示代码？</p>
<h2 id="代码的抽象表示"><a href="#代码的抽象表示" class="headerlink" title="代码的抽象表示"></a>代码的抽象表示</h2><p>代码的量和编写形式是无限的，但是 AST所能表示形式是有限的，如何用有限的形式表示无限的代码？这是一个问题。所以我们需要用一种抽象的形式来表示代码。<br>为了找个比较简单的研究案例，这里贡献一下拙作 enginx关于语法抽象代码的一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  ENGINX_BOOLEAN_VALUE = <span class="number">1</span>,</span><br><span class="line">  ENGINX_STRING_VALUE,</span><br><span class="line">  ENGINX_INT_VALUE,</span><br><span class="line">  ENGINX_NULL_VALUE,</span><br><span class="line">  ENGINX_IDENTIFIER_VALUE</span><br><span class="line">&#125; ENGINX_VALUE_TYPE;</span><br></pre></td></tr></table></figure>
<p>在 enginx中，我把所有的用于表示数据的类型都归纳为一个类型：<strong>ENGINX_VALUE_TYPE</strong>，这是一种简单的抽象，这样我们在语法分析的时候，只要遇到基础数据类型，我们都可以将它归纳到这里。<br>同样地，Clang的 AST中，类型的表示就是 Type，具体到某个语言的类型时便可以派生出 <strong>PointerType</strong>（指针类型）、<strong>ObjCObjectType</strong>（objc对象类型）、<strong>BuiltinType</strong>（内置基础数据类型）这些表示。<br>在 Clang的定义中，编程语言中无外乎包含三个东西：Type(类型），Decl(声明），Stmt（陈述），通过这三者的联结、重复或选择（alternative)就能构成一门编程语言。举个例子，下图的一段代码：</p>
<p><img src="/images/BNF.png" style="max-width:350px"></p>
<p>FunctionDecl、ParmVarDecl 都是基于 Decl派生的类，CompoundStmt、ReturnStmt、DeclStmt都是基于 Stmt派生的类。）</p>
<p>从上图中可以看到，一个<strong>FunctionDecl</strong>（函数的实现）由一个 <strong>ParmVarDecl</strong>联结 <strong>CompoundStmt</strong>组成。而这个函数的 <strong>CompoundStmt</strong> 由 <strong>DeclStmt</strong>和 <strong>ReturnStmt</strong>联结组成。如果我们继续深挖一层的话，还可以发现这段代码的<strong>ParmVarDecl</strong>由 <strong>BuiltinType</strong>和一个标识符字面量联结组成。<br>很明显一门编程语言中还有很多其他形态，我们都可以用这种方式描述出来。所以说从抽象的角度看，拥有无限种形态的编程语言便可以用有限的形式来表示。</p>
<h2 id="AST的结构"><a href="#AST的结构" class="headerlink" title="AST的结构"></a>AST的结构</h2><p>毫无疑问，实际的代码产生的 AST结构肯定非常复杂，我们可以先管中窥豹一哈。先写一个最简单的 C代码文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">someFunc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = x / <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>然后，使用 Clang自带的 ast dump插件查看这端 C代码由 Clang分析产生的 AST：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -Xclang -ast-dump -fsyntax-only test.c</span><br></pre></td></tr></table></figure>
<p>结果如图所示：</p>
<p><img src="/images/ast-dump.png" alt></p>
<p>可以看到， Clang AST的最顶层结构叫做 <strong>TranslationUnit</strong>，我们管它叫做“编译单元”。它的子节点前面跟了很多个 <strong>TypedefDecl</strong>，这些都是 Clang的内置定义，可以先不用管。然后我们碰到了 <strong>FunctionDecl</strong>，整体结构和我们上文例举的图基本一致，但是它的层次要更丰富一点，原理一致就不赘述了。</p>
<p>不过，我们从 Clang AST dump中可以看到每一个语法节点包含的信息还是比较多的，比如 <strong>FunctionDecl</strong>在 AST的内存地址是 0x7fecf7017538，它处于 &lt;test.c:2:1, line:5:1&gt; 的位置。这些信息有什么用？这正是我们接下来要讨论的 Clang AST的不同之处。</p>
<h1 id="Clang-AST的作用"><a href="#Clang-AST的作用" class="headerlink" title="Clang AST的作用"></a>Clang AST的作用</h1><p>如果你阅读过拙作 enginx的 AST源码，你会发现 enginx 的 AST还是 too young too simple的，甚至寻找一个节点都需要遍历整个树，每个节点所携带的信息仅仅只有语义而已，所以 enginx只能基于 AST解释运行，做不了更多其他的事。<br>我们从上文的 ast dump就能看到 Clang AST每个语法节点包含的信息是很丰富的，其实它的丰富程度远超过想象，所以我们在拿到 Clang AST的时候，用起来不会像 enginx的 AST那样捉襟见肘。<br>Clang AST 除了拥有像普通的编译器编译意义上的作用，其实更多地给普通开发者带来了参与到编译流程的能力，我们接下来通过一个简单示例展示如何使用 Clang AST的 API。</p>
<h2 id="搭建-LLVM-Clang开发环境"><a href="#搭建-LLVM-Clang开发环境" class="headerlink" title="搭建 LLVM/Clang开发环境"></a>搭建 LLVM/Clang开发环境</h2><p>网络上关于 LLVM/Clang开发环境的实践比较少，我们可以按照官方的一些文档顺藤摸瓜着去做：</p>
<ul>
<li>checkout 最新的 LLVM release分支</li>
<li>把 clang checkout 到 llvm/tools/clang 目录</li>
<li>checkout clang-tools-extra 到 llvm/tools/extra目录</li>
<li>checkout compiler-rt 到 llvm/tools/compiler-rt 目录</li>
<li>创建 build目录<ul>
<li>如果习惯使用 cmake，使用命令 cmake /path/to/llvm</li>
<li>如果习惯使用 Xcode，使用命令 cmake -G Xcode /path/to/llvm</li>
</ul>
</li>
</ul>
<h2 id="示例-基于符号的定义查找"><a href="#示例-基于符号的定义查找" class="headerlink" title="示例: 基于符号的定义查找"></a>示例: 基于符号的定义查找</h2><p>首先解释一下什么是基于符号的定义查找：我们在 IDE中查找一个类的定义时基本上都是基于符号的查找（或者混合文字匹配），这和普通的文字编辑器的匹配是不同的。比如你在 Xcode中点击跳转到一个类的定义，这很显然是基于符号分析实现的，IDE不会仅仅简单地通过文字匹配，假如通过文字匹配，很容易跳转到注释或某一处非常近似的语句中。</p>
<p>很显然，要实现符号的查找和定位，我们需要借助于语义分析来实现。假如 enginx（或者任何一个简单的其他拥有 AST结构的程序）需要实现编辑器这样一个辅助功能，查找一个符号显然只能通过不断地遍历 AST实现，效率很低，但好在 enginx AST的结构非常简单，遍历的开销并不高。但是这样的问题照搬到 C、C++、Objective-C和 Swift这些用于构建庞大应用，动辄数十万行量级的代码程序上，重复遍历的效率就无法令人接受了。<br>为此 Clang AST 封装了非常多、非常强大的 API可供我们使用，我们可以借助这些 API实现这次的示例: <strong>从 C++代码中 查找一个指定名称为 Demo的 Class，给出具体位置</strong>。</p>
<p>示例代码：    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ClangTutorial &#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><p>在 <code>llvm/tools/clang/examples</code>创建 FindNamedClass文件夹，在 <code>llvm/tools/clang/examples/CMakeLists.txt</code>最后添加一行：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(FindNamedClass)</span><br></pre></td></tr></table></figure>
<p>在 <strong>FindNamedClass</strong>文件夹添加 main.cpp文件，并添加 CMakeLists.txt文件，修改内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_clang_executable(findNamedClass main.cpp)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">target_link_libraries</span>(findNamedClass PRIVATE clangTooling)</span><br></pre></td></tr></table></figure>
<p>至此，我们工程文件创建好了，接下来可以正式写代码了。在写之前，需要到你的 build目录再 cmake一遍，确保配置到最新了。</p>
<h3 id="Clang-Tools"><a href="#Clang-Tools" class="headerlink" title="Clang Tools"></a>Clang Tools</h3><p>好吧，到这时候我们又引入了一个概念叫 Clang Tools。从上面的 CMake配置来看，我们这次要写的示例代码其实是一个独立运行的命令行程序，使用了 <strong>libclangTooling</strong>这个库。所以，Clang Tools就是通过 Clang提供的函数库实现的独立运行的工具。同样类型的 Clang Tools还有 clang-check、clang-fixit、clang-format这些大名鼎鼎的工具。</p>
<h3 id="RecursiveASTVisitor"><a href="#RecursiveASTVisitor" class="headerlink" title="RecursiveASTVisitor"></a>RecursiveASTVisitor</h3><p>在要动手写代码前，我们需要了解一下 Clang的库提供的这样一个封装。在拿到 Clang提供的 AST时，其顶层结构肯定是一个“编译单元”，去查找某个节点我们可以进行遍历，但也可以使用 Clang封装好的访问算法，这个算法的封装就是<strong>RecursiveASTVisitor</strong>。 我们继承这个类，并且实现其中的 <strong>VisitCXXRecordDecl</strong>，那么这个方法就会在访问 <strong>CXXRecordDecl</strong>类型的节点上触发。(CXXRecordDecl 类型用于表示 C++ class/union/struct)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindNamedClassVisitor</span> :</span> <span class="keyword">public</span> RecursiveASTVisitor&amp;lt;FindNamedClassVisitor&amp;gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">VisitCXXRecordDecl</span><span class="params">(CXXRecordDecl *Declaration)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以 dump一下看看到底有什么</span></span><br><span class="line">    <span class="keyword">if</span> (Declaration-&amp;gt;getQualifiedNameAsString() == <span class="string">"ClangTutorial::Demo"</span>)</span><br><span class="line">        Declaration-&amp;gt;dump();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个返回值表示是否需要接着访问其他节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="FrontendAction和-ASTConsumer"><a href="#FrontendAction和-ASTConsumer" class="headerlink" title="FrontendAction和 ASTConsumer"></a>FrontendAction和 ASTConsumer</h3><p>前面我们已经实现了 <strong>RecursiveASTVisitor</strong>, 按道理已经可以实现基于 Clang AST查找符号的核心逻辑了，但是很明显我们需要一个入口，这个入口需要定义我们如何通过一个编译实例(compiler instance)获得整个 AST以及如何进行 AST的访问。<br><strong>FrontendAction</strong>就是一个与编译实例打交道的东西，词法分析、语法分析等过程都被编译实例隐藏了，编译实例会触发 <strong>FrontendAction</strong>定义好的一些方法，并且把编译过程中的详细信息告诉它，比如编译了哪个文件、编译参数等。而 <strong>ASTConsumer</strong>其实是 <strong>FrontendAction</strong>的一个子过程产物，在 <strong>ASTConsumer</strong>中我们便可以拿到整个“编译单元”，调用前面的 Visitor进行访问和查找。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindNamedClassConsumer</span> :</span> <span class="keyword">public</span> clang::ASTConsumer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FindNamedClassConsumer</span><span class="params">(ASTContext *Context)</span> : <span class="title">Visitor</span><span class="params">(Context)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">HandleTranslationUnit</span><span class="params">(clang::ASTContext &amp;amp;Context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 RecursiveASTVisitor访问 translation unit会遍历 AST所有节点  </span></span><br><span class="line">    Visitor.TraverseDecl(Context.getTranslationUnitDecl());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// RecursiveASTVisitor 的具体实现.</span></span><br><span class="line">  FindNamedClassVisitor Visitor;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindNamedClassAction</span> :</span> <span class="keyword">public</span> clang::ASTFrontendAction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&amp;lt;clang::ASTConsumer&amp;gt; CreateASTConsumer(clang::CompilerInstance &amp;amp;Compiler, llvm::StringRef InFile) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&amp;lt;clang::ASTConsumer&amp;gt;(<span class="keyword">new</span> FindNamedClassConsumer(&amp;amp;Compiler.getASTContext()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>为了简化问题，我们直接调用 clangTooling的 runToolOnCode方法，传入代码字符串即开始解析。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &amp;gt; <span class="number">1</span>) &#123;</span><br><span class="line">        clang::tooling::runToolOnCode(<span class="keyword">new</span> FindNamedClassAction, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们进行编译和测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./findNameClass "namespace ClangTutorial &#123; class Demo &#123;&#125;; &#125;"</span><br></pre></td></tr></table></figure>
<p>如图所示</p>
<p><img src="/images/decl-dump.png" alt></p>
<p>我们已经能实现查找到指定的符号定义并 dump出来了，但是还没想到如何具体地获取它的位置等信息，要解决这个问题我们需要再引入一个概念。</p>
<h3 id="ASTContext"><a href="#ASTContext" class="headerlink" title="ASTContext"></a>ASTContext</h3><p>在前面的代码里面，我们偷偷地用了 <strong>ASTContext</strong>却没有介绍它。ASTContext其实就是编译实例保存所有 AST信息的一种结构，它主要包括编译期间的符号表和 AST原始形式。我们也是直接从 ASTContext里面获取到了整个 “编译单元”。<br>有了符号表，我们便可以获取到符号在 AST中的原始定义，不过 Clang的 API已经隐式地帮我们做了这件事：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Declaration-&gt;getQualifiedNameAsString() == <span class="string">"ClangTutorial::Demo"</span>) &#123;</span><br><span class="line">    FullSourceLoc FullLocation = Context-&gt;getFullLoc(Declaration-&gt;getLocStart());</span><br><span class="line">    <span class="keyword">if</span> (FullLocation.isValid())</span><br><span class="line">      llvm::outs() &lt;&lt; <span class="string">"Found declaration at "</span></span><br><span class="line">                   &lt;&lt; FullLocation.getSpellingLineNumber() &lt;&lt; <span class="string">":"</span></span><br><span class="line">                   &lt;&lt; FullLocation.getSpellingColumnNumber() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要通过上面代码中几个简单的 API和对象封装，我们便获得了符号定义的原始位置，我们再编译运行一遍，就获得了结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Found declaration at 1:27</span><br></pre></td></tr></table></figure>
<p>通过 Clang AST API，其实除了获取符号定义在源文件的位置，我们还可以获取方法的调用关系、类型定义以及源代码内容等，非常强大。</p>
<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><p>LLVM在设计之初就被设计为一系列库，Clang也是如此。通过这一系列库，开发者可以实现各种各样强大的功能，玩转编程语言。本文的 Clang AST只涉及 Clang的若干库中的一两个，更多更强大的功能可以访问 <a href="https://clang.llvm.org/docs/index.html" target="_blank" rel="noopener">Clang官方文档</a>查看。</p>
<p>本文参考了以下文章或网站：</p>
<ul>
<li><a href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">Clang 6 documentation/Introduction to the Clang AST</a></li>
<li><a href="https://clang.llvm.org/doxygen" target="_blank" rel="noopener">Clang doc</a></li>
<li><a href="http://clang.llvm.org/docs/RAVFrontendAction.html" target="_blank" rel="noopener">Clang 6 documentation/How to write RecursiveASTVisitor based ASTFrontendActions</a></li>
</ul>
<p>推荐书籍：</p>
<ul>
<li>《自制编程语言》前桥和弥 著</li>
<li>《Modern Compiler Implementation in C》 (美)安佩尔 著</li>
<li>《Compiler》 Alfred V.Aho等 著</li>
<li>《Getting Started with LLVM Core Libraries》Bruno Cardoso Lopes / Rafael Auler 著</li>
</ul>
<p>附文中示例完整代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/AST/ASTConsumer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/AST/RecursiveASTVisitor.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/Frontend/CompilerInstance.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/Frontend/FrontendAction.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"clang/Tooling/Tooling.h"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> clang;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindNamedClassVisitor</span>:</span> <span class="keyword">public</span> RecursiveASTVisitor&lt;FindNamedClassVisitor&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FindNamedClassVisitor</span><span class="params">(ASTContext *Context)</span> : <span class="title">Context</span><span class="params">(Context)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VisitCXXRecordDecl</span><span class="params">(CXXRecordDecl *Declaration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Declaration-&gt;getQualifiedNameAsString() == <span class="string">"ClangTutorial::Demo"</span>) &#123;</span><br><span class="line">            FullSourceLoc FullLocation = Context-&gt;getFullLoc(Declaration-&gt;getLocStart());</span><br><span class="line">            <span class="keyword">if</span> (FullLocation.isValid())</span><br><span class="line">                llvm::outs() &lt;&lt; <span class="string">"Found declaration at "</span></span><br><span class="line">                &lt;&lt; FullLocation.getSpellingLineNumber() &lt;&lt; <span class="string">":"</span></span><br><span class="line">                &lt;&lt; FullLocation.getSpellingColumnNumber() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ASTContext *Context;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindNamedClassConsumer</span> :</span> <span class="keyword">public</span> clang::ASTConsumer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FindNamedClassConsumer</span><span class="params">(ASTContext *Context)</span> : <span class="title">Visitor</span><span class="params">(Context)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">HandleTranslationUnit</span><span class="params">(clang::ASTContext &amp;Context)</span> </span>&#123;</span><br><span class="line">        Visitor.TraverseDecl(Context.getTranslationUnitDecl());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FindNamedClassVisitor Visitor;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindNamedClassAction</span> :</span> <span class="keyword">public</span> clang::ASTFrontendAction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;clang::ASTConsumer&gt; <span class="title">CreateASTConsumer</span><span class="params">(clang::CompilerInstance &amp;Compiler, llvm::StringRef InFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;clang::ASTConsumer&gt;(<span class="keyword">new</span> FindNamedClassConsumer(&amp;Compiler.getASTContext()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        clang::tooling::runToolOnCode(<span class="keyword">new</span> FindNamedClassAction, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div></main><footer><div class="paginator"><a href="/2018/04/20/dart-getting-start/" class="prev">PREV</a><a href="/2017/12/25/cmake/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2021 <a href="https://stephenwzl.github.io">stephenwzl</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>